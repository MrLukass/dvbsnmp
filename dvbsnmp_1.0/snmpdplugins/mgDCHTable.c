/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */
#include <linux/dvb/frontend.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "mgDCHTable.h"

#include "SNMPHelper.h"
#include "config.h"

static oid mgDCHTable_oid[] = {1, 3, 6, 1, 4, 1, 2696, 3, 10, 1, 1};
netsnmp_table_data_set *table_set;

/** Initializes the mgDCHTable module */
void init_mgDCHTable(void) {

    /* here we initialize all the tables we're planning on supporting */
    /* create the table structure itself */
    table_set = netsnmp_create_table_data_set("mgDCHTable");

    netsnmp_mib_handler *cache_handler;

    /* comment this out or delete if you don't support creation of new rows */
    table_set->allow_creation = 1;

    /***************************************************
     * Adding indexes
     */
    DEBUGMSGTL(("mgDCHTable", "adding indexes to table mgDCHTable\n"));
    netsnmp_table_set_add_indexes(table_set,
            ASN_INTEGER, /* index: mgDCHInputNumber */
            0);

    DEBUGMSGTL(("mgDCHTable", "adding column types to table mgDCHTable\n"));
    netsnmp_table_set_multi_add_default_row(table_set,
            COLUMN_MGDCHINPUTNUMBER, ASN_INTEGER, 0,
            NULL, 0,
            COLUMN_MGDCHSIGNALSTRENGTH, ASN_INTEGER, 0,
            NULL, 0,
            COLUMN_MGDCHSIGNALBER, ASN_INTEGER, 0,
            NULL, 0,
            COLUMN_MGDCHSIGNALSNR, ASN_INTEGER, 0,
            NULL, 0,
            COLUMN_MGDCHSIGNALUNCORRECTEDBLOCKS, ASN_INTEGER, 0,
            NULL, 0,
            COLUMN_MGDCHSIGNALFREQUENCY, ASN_INTEGER, 0,
            NULL, 0,
            0);

    /* registering the table with the master agent */
    /* note: if you don't need a subhandler to deal with any aspects
       of the request, change mgDCHTable_handler to "NULL" */
    netsnmp_handler_registration *reginfo = netsnmp_create_handler_registration("mgSignalStrengthTable", NULL,
            mgDCHTable_oid,
            OID_LENGTH(mgDCHTable_oid),
            HANDLER_CAN_RWRITE);

    netsnmp_register_table_data_set(reginfo, table_set, NULL);

    DEBUGMSGTL(("mgDCHTable", "Done initalizing mgDCHTable module\n"));

    cache_handler = netsnmp_get_cache_handler(SHORTCACHETIMEOUT, /* how long a cache is valid for */
            cache_load, /* a pointer to the cache loading function */
            cache_free, /* a pointer to the cache freeing function */
            mgDCHTable_oid, OID_LENGTH(mgDCHTable_oid)); /* the OID of the registration point */

    netsnmp_inject_handler(reginfo, cache_handler);
}

int cache_load(netsnmp_cache *cache, void *magic) {
    DEBUGMSGTL(("mgDCHTable", "load from mgDCHTable \n"));
    int mgDCHInputNumber = 1;
    int mgDCHSignalStrength = -1;
    int mgDCHSignalBER = -1;
    int mgDCHSignalSNR = -1;
    int mgDCHSignalUncorrectedBlocks = -1;
    int mgDCHSignalFrequency = -1;

    unsigned int adapter = 0;
    unsigned int frontend = 0;
    char fedev[128];
    int fefd, z;
    __u16 signal_strlength;
    __u16 snr;
    __u32 ber;
    __u32 uncorrected_block;
    struct dvb_frontend_info fe_info;
    struct dvb_frontend_parameters fe_param;
    netsnmp_table_row *row;

    cleanTableSet(table_set);


    while (mgDCHInputNumber <= MAXDEVICECOUNT) {
        snprintf(fedev, sizeof (fedev), FRONTENDDEVICE, adapter, frontend);

        if ((fefd = open(fedev, O_RDONLY | O_NONBLOCK)) < 0) {
            mgDCHInputNumber++;
            adapter++;
            perror("Open Frontend error");
            DEBUGMSGTL(("mgDCHTable", "cannot open frontend \n"));
            continue;

        }
        if (ioctl(fefd, FE_READ_SIGNAL_STRENGTH, &signal_strlength) >= 0) {
            mgDCHSignalStrength = (signal_strlength)*100 / (0xffff);
        } else {
            mgDCHSignalStrength = 0;
        }
        if (ioctl(fefd, FE_READ_SNR, &snr) >= 0) {
            mgDCHSignalSNR = (snr)*100 / (0xffff);
        }
        if (ioctl(fefd, FE_READ_BER, &ber) >= 0) {
            mgDCHSignalBER = ber;
        }
        if (ioctl(fefd, FE_READ_UNCORRECTED_BLOCKS, &uncorrected_block) >= 0) {
            mgDCHSignalUncorrectedBlocks = uncorrected_block;
        }
        if (ioctl(fefd, FE_GET_INFO, &fe_info) >= 0) {
            if (ioctl(fefd, FE_GET_FRONTEND, &fe_param) >= 0) {
                if (fe_info.type == FE_OFDM) {
                    if (fe_param.frequency + 10600000 >= 11700000) {
                        mgDCHSignalFrequency = (fe_param.frequency + 10600000) / 1000;
                    } else {
                        mgDCHSignalFrequency = (fe_param.frequency + 9750000)*1000;
                    }

                } else if (fe_info.type == FE_QAM || fe_info.type == FE_QPSK) {
                    if (fe_param.frequency + 10600000 >= 11700000) {
                        mgDCHSignalFrequency = (fe_param.frequency + 10600000);
                    } else {
                        mgDCHSignalFrequency = (fe_param.frequency + 9750000)*1000000;
                    }
                } else {
                    mgDCHSignalFrequency = -1;
                }
            } else {
                mgDCHSignalFrequency = -1;
            }
        }
        else {
            mgDCHSignalFrequency = -1;
        }

        close(fefd);
        row = netsnmp_create_table_data_row();
        netsnmp_table_row_add_index(row, ASN_INTEGER, &mgDCHInputNumber, sizeof (mgDCHInputNumber));
        netsnmp_set_row_column(row, 2, ASN_INTEGER, &mgDCHSignalStrength, sizeof (mgDCHSignalStrength));
        netsnmp_set_row_column(row, 3, ASN_INTEGER, &mgDCHSignalBER, sizeof (mgDCHSignalBER));
        netsnmp_set_row_column(row, 4, ASN_INTEGER, &mgDCHSignalSNR, sizeof (mgDCHSignalSNR));
        netsnmp_set_row_column(row, 5, ASN_INTEGER, &mgDCHSignalUncorrectedBlocks, sizeof (mgDCHSignalUncorrectedBlocks));
        netsnmp_set_row_column(row, 6, ASN_INTEGER, &mgDCHSignalFrequency, sizeof (mgDCHSignalFrequency));
        netsnmp_table_dataset_add_row(table_set, row);
        mgDCHInputNumber++;
        adapter++;

        mgDCHInputNumber = 1;
        mgDCHSignalStrength = -1;
        mgDCHSignalBER = -1;
        mgDCHSignalSNR = -1;
        mgDCHSignalUncorrectedBlocks = -1;
        mgDCHSignalFrequency = -1;
    }
    return SNMP_ERR_NOERROR;
}

void cache_free(netsnmp_cache *cache, void *magic) {
    DEBUGMSGTL(("mgDCHTable", "Free Handler\n"));
}

void deinit_mgDCHTable(void) {
    netsnmp_delete_table_data_set(table_set);
    table_set = NULL;
    unregister_mib(mgDCHTable_oid, OID_LENGTH(mgDCHTable_oid));
}
